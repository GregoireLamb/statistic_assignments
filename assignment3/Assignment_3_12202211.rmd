---
title: "Exercice n°3"
subtitle: "Monte Carlo Simulation of areas"
author: "Grégoire de Lambertye"
date: "`r Sys.Date()`"
header-includes:
   - \usepackage{amsmath,amssymb}
   - \usepackage[utf8]{inputenc}
output: pdf_document
---

# I Task n°1 :
 We will consider the following integral 
 $$
 \int_{1}^{b} e^{-x^3}
 $$
 ## I.1 Integral approximation with fixed bound
*Use uniformly distributed random variables to approximate the integral for b = 6 (using Monte Carlo integration). Then use the function integrate for comparison.*

At first, we will define the function we are trying to integrate. 

```{r, echo=TRUE}
to_integrate_fct <- function(x){
  return(exp(-x^3))
}
```

We will now try to approximate the value of  $$ \int_{1}^{6} e^{-x^3} $$ with the Monte Carlo method. 
```{r, echo=TRUE }
MC_for_b6 <- function(){
  u <- runif(100000,1,6)
  cat(paste("Monte Carlo Integral:",mean(to_integrate_fct(u)*(6-1))))
}
MC_for_b6()
```
For the comparison we calcul the same value with the function *integrate* provided by R. 
```{r}
R_value <- integrate(to_integrate_fct, 1,6)
R_value
```
 ## I.2 Integral approximation infinity bound
 *Use Monte Carlo integration to compute the integral for b = infinity . What would be a good density for the simulation in that case? Use also the function integrate for comparison.*

### What would be a good density for the simulation in that case?
We will first have a look on the function shape. 
```{r, echo=FALSE, fig.align='center' , out.width="70%"}
test <- seq(from=0, to=5, length.out=10000)
res = c()
dens = c()
for(i in 0:length(test)){
  res <- append(res, to_integrate_fct(test[i]))
  dens <- append(dens, dexp(test[i], rate=1.5))
}
plot(test, res, type="l", main="Function we have to integrate", ylim = c(0,1.6))
lines(test, dens, col = "red")
legend("topright", legend=c("function to integrate","exponential density"), col=c("black","red"), lty=1:1)

```
Our function is way more important between 0 and 2 but takes value from 0 to infinity. A good candidate seems to be the exponential density with $\lambda = 1.5$ as we can see on the previous graph. Choosing this density will reduce our variance.  
We use the transformation 
 $$
   \int_{1}^{\infty} e^{-x^3} =  \int_{0}^{\infty} e^{-(x+1)^3}
 $$

 
```{r}
MC_for_binfinity <- function(){
  u <- rexp(10000, rate=1.5)
  cat(paste("Monte Carlo Integral:",mean(to_integrate_fct(u+1)/dexp(u, rate=1.5)))) 
}
MC_for_binfinity()

```
 
 For the comparison we calcul the same value with the function *integrate* provided by R. 
```{r}
R_value <- integrate(to_integrate_fct, 1,Inf)
R_value
```
 Our result with the Monte Carlo's method seem correct.
 
 ## I.3 Discution
*Do you have an explanation why Monte Carlo integration agrees in 2. with integrate but not so much in 1.?*
For sampling and summing up the area with the biggest part has to greathest impact on the result. This is for small values of X. We do have more points in that area of interest for example 2 because we provided a better distribution for that problem. In 1 we simple use the unified distribution, because we dont have better shaped one here.

# II Task n°2: 
We will try to approch the area of 
$$
r(t) = (exp(cos(t))-2*cos(4t)-sin(t/12)^5) \text{ for } t\in[-\pi,\pi]
$$
We wil use the polar coodinates : 
$$
x=r(t) * sint(t)
$$
$$
y = r(t)*cos(t)
$$

 ## II.1 Visualization of the area.
*Visualise the function and the area.*
```{r}
library(ggplot2)

r_function <- function(t){
  return(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)
}

x_polar <- function(x){
  return(r_function(x)*sin(x))  
}

y_polar <- function(y){
  return(r_function(y)*cos(y))  
}


t <- seq(from=-pi, to=pi, length.out=1000)
r_t = c()
x_cal = c()
y_cal = c()
for(i in 0:length(t)){
  #x_cal <- append(x_cal, x_polar(t[i]))
  #y_cal <- append(y_cal, y_polar(t[i]))
  
  x_cal <- append(x_cal, x_polar(t[i]))
  y_cal <- append(y_cal, y_polar(t[i]))
  r_t <- append(r_t, r_function(t[i]))
}
plot(x_cal, y_cal,type="l", main="r area")
plot(t, r_t,type="l", main="r curve from -pi to pi", xlim=c(-pi,pi))

```


 ## II.2
 *Generate uniform random coordinates within the rectangle [−3,3]×[−2,3.5] and an indicator whether this point lies within the area in question*
 
```{r}
n <- 100000
x_rnd <- runif(n,-3,3)
y_rnd <- runif(n,-2,3.5)

is_in_area <-function(x, y) {
  if (y > 0){
    #for negative values of f
    alpha <- 0
  } else {
     #for positive values of f
    alpha <- pi
  }
  rad <- sqrt(x^2 + y^2)
  beta <- atan(x/y) + alpha
  if (r_function(beta) > 0 & (rad < abs(r_function(beta)))) {
    # the point is in the positive part of r(t)
    return(TRUE)
  } else if (r_function(beta+pi) < 0 & (rad < abs(r_function(beta + pi)))) {
    return(TRUE)
  } else {
    return(FALSE)
  }
}

inside <- logical(n)
for (i in 1:n){
  inside[i] <- is_in_area(x_rnd[i], y_rnd[i])
}

df <- data.frame(x_rnd, y_rnd, inside)

ggplot()+
  geom_point(data= df, aes(x=x_rnd, y=y_rnd, color = inside ), size = 0.1)
#+
 # geom_path(aes(x=x_polar(x), y=y_polar(y)))
```
 
 ## II.3
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
